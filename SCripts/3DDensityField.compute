// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "./Tools.compute"

int FieldWidth;
int FieldHeight;
int FieldDepth;
float VoxelSize;
RWStructuredBuffer<float3> PredictedPosition;
RWStructuredBuffer<float> DensityValuesBuffer;
RWTexture3D<float> DensityTexture;

float CalcDensity(float3 RealPos) {
    float Density = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(RealPos,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                //-----------------------------------
                float3 Direction = PredictedPosition[Hashes[StartIndex].index]-RealPos;
                float sqrDstToNeighbour = dot(Direction, Direction);
                float Distance = sqrt(sqrDstToNeighbour);

                if (sqrDstToNeighbour < sqrRadius) {
                    Density+=SpikyKernelPow23D(Distance,SmoothingRadius);
                }
                //-----------------------------------
            }
            StartIndex++;
        }
    }
    return Density;
}
bool isBorder(uint3 id) {
    if(id.x == 0) {
        return true;
    }
    if(id.x >= FieldWidth-1) {
        return true;
    }
    if(id.y == 0) {
        return true;
    }
    if(id.y >= FieldHeight-1) {
        return true;
    }
    if(id.z == 0) {
        return true;
    }
    if(id.z >= FieldDepth-1) {
        return true;
    }
    return false;
}
[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    if ((id.x >= FieldWidth)) return;
    if ((id.y >= FieldHeight)) return;
    if ((id.z >= FieldDepth)) return;

    float3 RealPos = float3(-FieldWidth/2,0,-FieldDepth/2)* VoxelSize + ((float3)id) * VoxelSize;

    if(isBorder(id)) {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = 0;
        DensityTexture[id] =  0;
    }else {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = CalcDensity(RealPos);
        DensityTexture[id] = DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight];
    }
}
