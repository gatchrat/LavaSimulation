// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Simulation
#pragma kernel DensityCache
#pragma kernel CalcHashes
#pragma kernel SortHashes
#pragma kernel CalcStartingIndizes
#pragma kernel March
#pragma kernel LOADSDF
#pragma kernel DensityField
#pragma kernel PredictPositions
#pragma kernel UpdateSpatialHash
#pragma kernel ReorderCopyBack
#pragma kernel Reorder
#pragma kernel SortHashesNeu
#pragma kernel InitializeOffsets
#pragma kernel  CalculateOffsets 
#pragma kernel Activate

#include "./Tools.compute"
#include "./SpatialHash3D.compute"

float TimePassed;
float TargetDensity; // How thick is the Liquid
float PressureMultiplier; //How Fast should we reach the target state
float NearPressureMultiplier;
float ViscosityMultiplier;
float BoundsWidth; //Centered on 0
float BoundsHeight; //Beginning on 0
float BoundsDepth; //Centered on 0
// Grid size and threshold
int3 GridSize;
float IsoLevel;
int FieldWidth;
int FieldHeight;
int FieldDepth;
float VoxelSize;
//SDF
float3 SDF_OffSet;
float3 SDF_Scale;
RWStructuredBuffer<float3> PredictedPosition;
RWStructuredBuffer<float> DensityValuesBuffer;
RWTexture3D<float> DensityTexture; // 3D Density Field
RWStructuredBuffer<float2> CachedDensities;
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> VertexCount;
RWStructuredBuffer<float> SDFValues;

//SEB
RWStructuredBuffer<uint> SpatialKeys; // used for spatial hashing
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing
RWStructuredBuffer<uint> SortedIndices;

// Lookup tables
StructuredBuffer<int> EdgeTable;      // 256 entries
StructuredBuffer<int> TriTable;       // 256 * 16 entries

//--------Slightly adapted from: https://github.com/SebLague/Fluid-Planet/blob/main/Assets/Scripts/Simulation/Compute/FluidSim.compute
RWTexture3D<float> SDFTexture;
Texture3D<float4> SDFReadTexture;
float3 SDFSize;
uint3 SDFValueCount;
SamplerState linearClampSampler;

const float4x4 sdfWorldToLocalMatrix;
float SampleSDF(float3 posWorld) {
    float3 sdfWorldSize = float3(SDFSize.x,SDFSize.y,SDFSize.z);
    float3 uvw = (posWorld + sdfWorldSize / 2) / sdfWorldSize;
    float dstFromSurface = SDFReadTexture.SampleLevel(linearClampSampler, uvw, 0).r;
    return dstFromSurface;
}

float3 calculateSDFNormal(float3 pos) {
    const float s = 0.4;
    float3 offsetX = int3(1, 0, 0) * s;
    float3 offsetY = int3(0, 1, 0) * s;
    float3 offsetZ = int3(0, 0, 1) * s;

    float dx = SampleSDF(pos + offsetX) - SampleSDF(pos - offsetX);
    float dy = SampleSDF(pos + offsetY) - SampleSDF(pos - offsetY);
    float dz = SampleSDF(pos + offsetZ) - SampleSDF(pos - offsetZ);

    return normalize(float3(dx, dy, dz));
}
float3 WorldToSDF(float3 pos) {
    pos = pos - float3(SDF_OffSet.x,SDF_OffSet.y,SDF_OffSet.z);
    float3 tempScale = SDF_Scale*0.333333333; //Till i figure iout how to do the sdf at 1 scale
    pos = float3(pos.x/tempScale.x,pos.y/tempScale.y,pos.z/tempScale.z);
    return pos;
}
void ResolveCollisionsSDF(inout float3 pos, inout float3 vel, float collisionDamping) {
    float dstFromSurface = SampleSDF(WorldToSDF(pos))-0.1;

    if (dstFromSurface < 0) {
        float3 up = calculateSDFNormal(WorldToSDF(pos)); // Richtung zu
        pos -= up * min(0, dstFromSurface);
        if (dot(vel, up) < 0) {
            vel -= up * dot(up, vel);
            vel *= collisionDamping;
        }
    }
}
//-----------------------------------------------------------------------------------------------------------------------

float3 CalcPosition (LavaPoint Point) {
    return Point.Position+Point.Velocity*TimePassed;
}
float GetPressureFromDensity(float Density) {
    float DensityDiff = Density-TargetDensity;
    float Pressure = DensityDiff * PressureMultiplier;
    return Pressure;
}
float NearPressureFromDensity(float NearDensity) {
    return NearDensity * NearPressureMultiplier;
}
float CalcSharedPressure(float DensityA, float DensityB) {
    float a = GetPressureFromDensity(DensityA);
    float b = GetPressureFromDensity(DensityB);
    return(a+b)/2;
}
float CalcSharedNearPressure(float DensityA, float DensityB) {
    float a = NearPressureFromDensity(DensityA);
    float b = NearPressureFromDensity(DensityB);
    return(a+b)/2;
}
float3 CalcPressureForce(int PointID) {
    LavaPoint Point = Points[PointID];

    float2 Density = CachedDensities[PointID];
    if(Density.x == 0) {
        return float3(0,0,0);
    }
    float3 DirectionalPressure = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    float3 MyPosition = PredictedPosition[PointID];
    int3 originCell = GetCell3D(MyPosition, SmoothingRadius);

    for (int i = 0; i < 27; i++) {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, ParticleCount);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < ParticleCount) {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == PointID)
            continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
            break;
            //-----------------------------------
            float3 Direction = PredictedPosition[neighbourIndex]-MyPosition;
            float sqrDstToNeighbour = dot(Direction,Direction);
            float Distance = sqrt(sqrDstToNeighbour);

            if (sqrDstToNeighbour <= sqrRadius) {
                float3 AbsDirection = Distance > 0 ? Direction / Distance : float3(0, 1,0);
                float NeighborDensity = CachedDensities[neighbourIndex].x;
                float Slope = DerivativeSpikyPow23D(Distance,SmoothingRadius);
                float SharedPressure = CalcSharedPressure(Density.x,NeighborDensity);
                float NeighborNearDensity = CachedDensities[neighbourIndex].y;
                float NearSlope = DerivativeSpikyPow33D(Distance,SmoothingRadius);
                float NearSharedPressure = CalcSharedNearPressure(Density.y,NeighborNearDensity);
                if(NeighborDensity > 0) {
                    DirectionalPressure += AbsDirection*Slope*SharedPressure/NeighborDensity;
                    DirectionalPressure += AbsDirection*NearSlope*NearSharedPressure/NeighborNearDensity;
                }
            }
            //-----------------------------------
        }
    }
    return DirectionalPressure/Density.x;
}

//Particles closeby slow me down or speed me up, kinda like friction.
float3 CalcViscosityForce(int PointID) {
    if (ViscosityMultiplier == 0) {
        return float3(0,0,0);
    }
    LavaPoint Point = Points[PointID];

    float3 ViscosityForce = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    float3 MyPosition = PredictedPosition[PointID];
    int3 originCell = GetCell3D(MyPosition, SmoothingRadius);

    for (int i = 0; i < 27; i++) {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, ParticleCount);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < ParticleCount) {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == PointID)
            continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
            break;
            //-----------------------------------
            float3 Direction = PredictedPosition[neighbourIndex]-MyPosition;
            float sqrDstToNeighbour = dot(Direction,Direction);
            float Distance = sqrt(sqrDstToNeighbour);

            if (sqrDstToNeighbour <= sqrRadius) {
                float3 NeighborVelocity = Points[neighbourIndex].Velocity;
                float Influence = SmoothingKernelPoly63D(Distance,SmoothingRadius);
                ViscosityForce += (NeighborVelocity-Point.Velocity)*Influence;
            }
            //-----------------------------------
        }
    }
    return float3(ViscosityForce.x,ViscosityForce.y,ViscosityForce.z)*ViscosityMultiplier;
}

float3 CalcVelocity (int PointID) {
    LavaPoint Point = Points[PointID];
    const float3 Gravity = float3(0,-9.81,0);
    Point.Velocity+=Gravity*TimePassed;
    //F =a/m where m is the density because fluid
    Point.Velocity +=CalcPressureForce(PointID)*TimePassed;
    Point.Velocity +=CalcViscosityForce(PointID)*TimePassed;
    return Point.Velocity;
}

LavaPoint ReColor(int PointID) {
    LavaPoint Point = Points[PointID];
    Point.Color =  float4(CachedDensities[PointID].x,0,0,0);
    return Point;
}

LavaPoint HandleCollision(LavaPoint Point) {
    if(Point.active == 0) {
        return Point;
    }
    const float EnergyLossOnCollision = 0.5f;
    const float EnergyLossOnCollisionFloor = 0.7f;
    if (Point.Position.y < 0) {
        Point.Position.y = 0;
        Point.Velocity = float3(Point.Velocity.x,-Point.Velocity.y*EnergyLossOnCollisionFloor,Point.Velocity.z);
    }
    if (Point.Position.y > BoundsHeight) {
        Point.Position.y = BoundsHeight;
        Point.Velocity = float3(Point.Velocity.x,-Point.Velocity.y*EnergyLossOnCollisionFloor,Point.Velocity.z);
    }
    if (Point.Position.x < -BoundsWidth/2) {
        Point.Position.x = -BoundsWidth/2;
        Point.Velocity = float3(-Point.Velocity.x*EnergyLossOnCollision,Point.Velocity.y,Point.Velocity.z);
    }
    if (Point.Position.x > BoundsWidth/2) {
        Point.Position.x = BoundsWidth/2;
        Point.Velocity = float3(-Point.Velocity.x*EnergyLossOnCollision,Point.Velocity.y,Point.Velocity.z);
    }
    if (Point.Position.z < -BoundsDepth/2) {
        Point.Position.z = -BoundsDepth/2;
        Point.Velocity = float3(Point.Velocity.x,Point.Velocity.y,-Point.Velocity.z*EnergyLossOnCollision);
    }
    if (Point.Position.z > BoundsDepth/2) {
        Point.Position.z = BoundsDepth/2;
        Point.Velocity = float3(Point.Velocity.x,Point.Velocity.y,-Point.Velocity.z*EnergyLossOnCollision);
    }
    float3 Position = Point.Position;
    float3 Velocity = Point.Velocity;

    ResolveCollisionsSDF(Position, Velocity,EnergyLossOnCollision);

    Point.Position = Position;
    Point.Velocity = Velocity;

    return Point;
}

[numthreads(8,1,1)]
void Simulation (uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];
    if(CurPoint.active == 0) {
        return;
    }
    CurPoint = ReColor(id.x);
    CurPoint.Velocity = CalcVelocity(id.x);
    CurPoint.Position = CalcPosition(CurPoint);
    Points[id.x] = HandleCollision(CurPoint);
} 
[numthreads(1,1,1)]
void Activate (uint3 id : SV_DispatchThreadID) {
    for(int i = 0; i < ParticleCount; i++) {
        if(Points[i].active == 0) {
            Points[i].active = 1;
            Points[i].Position = float3(0,0.5,0);
            Points[i].Velocity = float3(0,0,0);
            return;
        }
    }
}
//------------------------------------------------------------DENSITY CACHE ---------------------------------------------------------------------------------

float2 CalcDensity(int PointID) {
    float2 Density = (0,0);
    float sqrRadius = SmoothingRadius * SmoothingRadius;
    float3 MyPosition = PredictedPosition[PointID];
    int3 originCell = GetCell3D(MyPosition, SmoothingRadius);

    for (int i = 0; i < 27; i++) {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, ParticleCount);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < ParticleCount) {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
            break;
            //-----------------------------------
            float3 Direction = PredictedPosition[neighbourIndex]-MyPosition;
            float sqrDstToNeighbour = dot(Direction, Direction);
            float Distance = sqrt(sqrDstToNeighbour);

            if (sqrDstToNeighbour <= sqrRadius) {
                Density.x+=SpikyKernelPow23D(Distance,SmoothingRadius);
                Density.y+=SpikyKernelPow33D(Distance,SmoothingRadius);
            }
            //-----------------------------------
        }
    }
    return Density;
}
[numthreads(8,1,1)]
void DensityCache (uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];
    CachedDensities[id.x] = CalcDensity(id.x);
}
//------------------------------------------------------------DENSITY FIELD ---------------------------------------------------------------------------------
float CalcDensitycringe(float3 RealPos) {
    float Density = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(RealPos,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                //-----------------------------------
                float3 Direction = PredictedPosition[Hashes[StartIndex].index]-RealPos;
                float sqrDstToNeighbour = dot(Direction, Direction);
                float Distance = sqrt(sqrDstToNeighbour);

                if (sqrDstToNeighbour < sqrRadius) {
                    Density+=SpikyKernelPow23D(Distance,SmoothingRadius);
                }
                //-----------------------------------
            }
            StartIndex++;
        }
    }
    return Density;
}
bool isBorder(uint3 id) {
    if(id.x == 0) {
        return true;
    }
    if(id.x >= FieldWidth-1) {
        return true;
    }
    if(id.y == 0) {
        return true;
    }
    if(id.y >= FieldHeight-1) {
        return true;
    }
    if(id.z == 0) {
        return true;
    }
    if(id.z >= FieldDepth-1) {
        return true;
    }
    return false;
}
[numthreads(8,8,8)]
void DensityField (uint3 id : SV_DispatchThreadID) {
    if ((id.x >= FieldWidth)) return;
    if ((id.y >= FieldHeight)) return;
    if ((id.z >= FieldDepth)) return;

    float3 RealPos = float3(-FieldWidth/2,0,-FieldDepth/2)* VoxelSize + ((float3)id) * VoxelSize;

    if(isBorder(id)) {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = 0;
        DensityTexture[id] =  0;
    }else {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = CalcDensity(RealPos);
        DensityTexture[id] = DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight];
    }
}
//------------------------------------------------------------POSITION PREDICTOR ---------------------------------------------------------------------------------
float3 PredictPosition(int PointID) {
    LavaPoint CurPoint = Points[PointID];
    float3 PredictedPosition = CurPoint.Position + (CurPoint.Velocity+float3(0,-9.81,0)/120)/120;
    return PredictedPosition;
}
[numthreads(1024,1,1)]
void PredictPositions (uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount) {
        return;
    }
    PredictedPosition[id.x] = PredictPosition(id.x);
}
//------------------------------------------------------------LOAD SDF---------------------------------------------------------------------------------
[numthreads(8,8,8)]
void LOADSDF (uint3 id : SV_DispatchThreadID) {
    if(any(id >= SDFValueCount)) {
        return;
    }
    SDFTexture[id] = SDFValues[id.x+id.y*SDFValueCount.x+id.z*SDFValueCount.x*SDFValueCount.y];
}

//------------------------------------------------------------MARCHING CUBES ---------------------------------------------------------------------------------
static const int3 vertexOffset[8] = {
    int3(0, 0, 0), // 0
    int3(1, 0, 0), // 1
    int3(0, 1, 0), // 2
    int3(1, 1, 0), // 3
    int3(0, 0, 1), // 4
    int3(1, 0, 1), // 5
    int3(0, 1, 1), // 6
    int3(1, 1, 1)  // 7
};

static const int2 edgeVertexIndices[12] = {
    int2(0, 1), // 0
    int2(1, 3), // 1
    int2(3, 2), // 2
    int2(2, 0), // 3
    int2(4, 5), // 4
    int2(5, 7), // 5
    int2(7, 6), // 6
    int2(6, 4), // 7
    int2(0, 4), // 8
    int2(1, 5), // 9
    int2(3, 7), // 10
    int2(2, 6)  // 11
};

float3 VertexInterp(float iso, float3 p1, float3 p2, float valp1, float valp2) {
    if (abs(valp2 - valp1) < 1e-6) return 0.5 * (p1 + p2);
    float t = (iso - valp1) / (valp2 - valp1);
    return lerp(p1, p2, t);
}

[numthreads(8,8,8)]
void March(uint3 id : SV_DispatchThreadID) {
    if (id.x >= GridSize.x || id.y >= GridSize.y || id.z >= GridSize.z) return;

    float cube[8];
    float3 pos[8];

    // Sample density field and convert to world positions
    for (int i = 0; i < 8; i++) {
        int3 offset = id + vertexOffset[i];
        cube[i] = DensityTexture.Load(int4(offset, 0));
        pos[i] = offset *VoxelSize;
    }

    // Build cube index
    int cubeIndex = 0;
    for (i = 0; i < 8; i++) {
        if (cube[i] < IsoLevel) cubeIndex |= (1 << i);
    }

    int edgeFlags = EdgeTable[cubeIndex];
    if (edgeFlags == 0) return;

    float3 vertList[12];

    for (i = 0; i < 12; i++) {
        if (edgeFlags & (1 << i)) {
            int2 e = edgeVertexIndices[i];
            // Use the midpoint of the edge (between the two vertices)
            vertList[i] = VertexInterp(IsoLevel, pos[e.x], pos[e.y], cube[e.x], cube[e.y]);
        }
    }

    // Create triangles
    for (i = 0; i < 16; i += 3) {
        int index1 = TriTable[cubeIndex * 16 + i];
        if (index1 == -1) break; // End of triangles for this cube

        int index2 = TriTable[cubeIndex * 16 + i + 1];
        if (index2 == -1) break; 
        int index3 = TriTable[cubeIndex * 16 + i + 2];
        if (index3 == -1) break; 

        uint baseIndex;
        InterlockedAdd(VertexCount[0], 3, baseIndex); // Reserve space for 3 vertices

        //Unity does clockwise not counterclockwise
        VertexBuffer[baseIndex+2] = vertList[index1]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex + 1] = vertList[index2]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex] = vertList[index3]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
    }
}
//------------------------------------------------------------STANDARD HASH ---------------------------------------------------------------------------------
//Idea: Turn the Simulation area into grids
//When searching for neioghbors simply look only into my and neighboring grids
//Nutzen Spacial Hash von https://cg.informatik.uni-freiburg.de/publications/2011_CGF_dataStructuresSPH.pdf
//SpÃ¤ter vielleich compact spacial Hash
//Compute Hash for Point
//Sort Points by Hash
//Save Starting indizes for Each Hash
//To get neibors
//Calc my hash and of each surrounding grid
//Based on the start indizes go through points and calc distance

[numthreads(8,1,1)]
void CalcHashes (uint3 id : SV_DispatchThreadID) {
    if(id.x >=ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];

    Hashes[id.x].hash =CalcHash(CurPoint.Position+float3(10,0,10));//Move Pos to always be positive
    Hashes[id.x].index = id.x;
}
//SOURCE:https://github.com/SebLague/Fluid-Sim/blob/Episode-01/Assets/Scripts/Compute%20Helpers/GPU%20Sort/Resources/BitonicMergeSort.compute
//------------------------------------------------------------------------------------------------------------------------------------------
const uint numEntries;
const uint groupWidth;
const uint groupHeight;
const uint stepIndex;

// Sort the given entries by their keys (smallest to largest)
// This is done using bitonic merge sort, and takes multiple iterations
[numthreads(128, 1, 1)]
void SortHashes (uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= numEntries) return;

    uint valueLeft = Hashes[indexLeft].hash;
    uint valueRight = Hashes[indexRight].hash;

    // Swap entries if value is descending
    if (valueLeft > valueRight) {
        HashEntry temp = Hashes[indexLeft];
        Hashes[indexLeft] = Hashes[indexRight];
        Hashes[indexRight] = temp;
    }
}
[numthreads(128, 1, 1)]
void SortHashesNeu (uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= numEntries) return;

    uint valueLeft = SpatialKeys[indexLeft];
    uint valueRight = SpatialKeys[indexRight];

    // Swap entries if value is descending
    if (valueLeft > valueRight) {
        uint temp = SpatialKeys[indexLeft];
        SpatialKeys[indexLeft] = SpatialKeys[indexRight];
        SpatialKeys[indexRight] = temp;

        temp = SortedIndices[indexLeft];
        SortedIndices[indexLeft] = SortedIndices[indexRight];
        SortedIndices[indexRight] = temp;
    }
}
//------------------------------------------------------------------------------------------------------------------------------------------
[numthreads(1024, 1, 1)]
void CalcStartingIndizes(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    if (i >= HashesBufferSize) return;

    uint currentHash = Hashes[i].hash;

    if (i == 0) {
        // First entry always starts a new hash group
        StartingIndizes[currentHash] = 0;
    }
    else {
        uint prevHash = Hashes[i - 1].hash;

        if (currentHash != prevHash) {
            StartingIndizes[currentHash] = i;
        }
    }
}

//SEB HASH REPLACE LATER 
[numthreads(1024, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount)
    return;

    uint index = id.x;
    int3 cell = GetCell3D(PredictedPosition[index], SmoothingRadius);
    uint hash = HashCell3D(cell);
    uint key = KeyFromHash(hash, ParticleCount);

    SpatialKeys[id.x] = key;
    SortedIndices[id.x] = id.x;
    SpatialOffsets[id.x] = ParticleCount; // Reset offsets
}

RWStructuredBuffer<LavaPoint> SortTarget_Points;
RWStructuredBuffer<float3> SortTarget_PredictedPositions;

[numthreads(1024, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount)
    return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Points[id.x] = Points[sortedIndex];

    SortTarget_PredictedPositions[id.x] = PredictedPosition[sortedIndex];
}

[numthreads(1024, 1, 1)]
void ReorderCopyBack(uint3 id : SV_DispatchThreadID) {
    if (id.x >= ParticleCount)
    return;

    Points[id.x] = SortTarget_Points[id.x];
    PredictedPosition[id.x] = SortTarget_PredictedPositions[id.x];
}

StructuredBuffer<uint> SortedKeys;
RWStructuredBuffer<uint> Offsets;
uint numInputs;

[numthreads(256, 1, 1)]
void InitializeOffsets(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numInputs) {
        return;
    }
    Offsets[id.x] = numInputs;
}

[numthreads(256, 1, 1)]
void CalculateOffsets(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numInputs) {
        return;
    }

    uint i = id.x;
    uint null = numInputs;

    uint key = SortedKeys[i];
    uint keyPrev = i == 0 ? null : SortedKeys[i - 1];

    if (key != keyPrev) {
        Offsets[key] = i;
    }
}