// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Simulation
#pragma kernel DensityCache
#pragma kernel CalcHashes
#pragma kernel SortHashes
#pragma kernel CalcStartingIndizes
#pragma kernel March
#pragma kernel LOADSDF
#pragma kernel DensityField
#pragma kernel PredictPositions
#include "./Tools.compute"

float TimePassed;
float TargetDensity; // How thick is the Liquid
float PressureMultiplier; //How Fast should we reach the target state
float NearPressureMultiplier;
float ViscosityMultiplier;
float BoundsWidth; //Centered on 0
float BoundsHeight; //Beginning on 0
float BoundsDepth; //Centered on 0
// Grid size and threshold
int3 GridSize;
float IsoLevel;
float MaxSpeed;
int FieldWidth;
int FieldHeight;
int FieldDepth;
float VoxelSize;
RWStructuredBuffer<float3> PredictedPosition;
RWStructuredBuffer<float> DensityValuesBuffer;
RWTexture3D<float> DensityTexture; // 3D Density Field
RWStructuredBuffer<float2> CachedDensities;
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> VertexCount;
RWStructuredBuffer<float> SDFValues;

// Lookup tables
StructuredBuffer<int> EdgeTable;      // 256 entries
StructuredBuffer<int> TriTable;       // 256 * 16 entries

//--------Slightly adapted from: https://github.com/SebLague/Fluid-Planet/blob/main/Assets/Scripts/Simulation/Compute/FluidSim.compute
RWTexture3D<float> SDFTexture;
uint3 SDFSize;
SamplerState linearClampSampler;

const float4x4 sdfWorldToLocalMatrix;
float SampleSDF(float3 posWorld) {
    posWorld = posWorld + (BoundsWidth/2,0,BoundsDepth/2); // Undo the bounds offset
    posWorld = posWorld / (BoundsWidth/SDFSize.x,BoundsHeight/SDFSize.y, BoundsDepth/SDFSize.z); // Scale the Bounds value to fit inside the SDF Bounds, both should have same Verh√§ltnisse
    float dstFromSurface = SDFTexture[posWorld];
    return dstFromSurface;
}

float3 calculateSDFNormal(float3 pos) {
    const float s = 0.4;
    float3 offsetX = int3(1, 0, 0) * s;
    float3 offsetY = int3(0, 1, 0) * s;
    float3 offsetZ = int3(0, 0, 1) * s;

    float dx = SampleSDF(pos + offsetX) - SampleSDF(pos - offsetX);
    float dy = SampleSDF(pos + offsetY) - SampleSDF(pos - offsetY);
    float dz = SampleSDF(pos + offsetZ) - SampleSDF(pos - offsetZ);

    return normalize(float3(dx, dy, dz));
}

void ResolveCollisionsSDF(inout float3 pos, inout float3 vel, float collisionDamping) {
    float dstFromSurface = SampleSDF(pos);

    if (dstFromSurface < 0) {
        float3 up = calculateSDFNormal(pos);
        pos -= up * min(0, dstFromSurface);

        if (dot(vel, up) < 0) {
            vel -= up * dot(up, vel);
            vel *= collisionDamping;
        }
        //pos = (0,0,0);
    }
}
//-----------------------------------------------------------------------------------------------------------------------

float3 CalcPosition (LavaPoint Point) {
    return Point.Position+Point.Velocity*TimePassed;
}
float GetPressureFromDensity(float Density) {
    float DensityDiff = Density-TargetDensity;
    float Pressure = DensityDiff * PressureMultiplier;
    return Pressure;
}
float NearPressureFromDensity(float NearDensity) {
    return NearDensity * NearPressureMultiplier;
}
float CalcSharedPressure(float DensityA, float DensityB) {
    float a = GetPressureFromDensity(DensityA);
    float b = GetPressureFromDensity(DensityB);
    return(a+b)/2;
}
float CalcSharedNearPressure(float DensityA, float DensityB) {
    float a = NearPressureFromDensity(DensityA);
    float b = NearPressureFromDensity(DensityB);
    return(a+b)/2;
}
float3 CalcPressureForce(int PointID) {
    LavaPoint Point = Points[PointID];

    float2 Density = CachedDensities[PointID];
    if(Density.x == 0) {
        return float3(0,0,0);
    }
    float3 DirectionalPressure = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    float3 MyPosition = PredictedPosition[PointID];

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(MyPosition,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                uint Index = Hashes[StartIndex].index;
                if(Index != PointID) {
                    //-----------------------------------
                    float3 Direction = PredictedPosition[Index]-MyPosition;
                    float sqrDstToNeighbour = dot(Direction,Direction);
                    float Distance = sqrt(sqrDstToNeighbour);

                    if (sqrDstToNeighbour <= sqrRadius) {
                        float3 AbsDirection = Distance > 0 ? Direction / Distance : float3(0, 1,0);
                        float NeighborDensity = CachedDensities[Index].x;
                        float Slope = DerivativeSpikyPow23D(Distance,SmoothingRadius);
                        float SharedPressure = CalcSharedPressure(Density.x,NeighborDensity);
                        float NeighborNearDensity = CachedDensities[Index].y;
                        float NearSlope = DerivativeSpikyPow33D(Distance,SmoothingRadius);
                        float NearSharedPressure = CalcSharedNearPressure(Density.y,NeighborNearDensity);
                        if(NeighborDensity > 0) {
                            DirectionalPressure += AbsDirection*Slope*SharedPressure/NeighborDensity;
                            DirectionalPressure += AbsDirection*NearSlope*NearSharedPressure/NeighborNearDensity;
                        }
                    }
                    //-----------------------------------
                }
            }
            StartIndex++;
        }
    }
    return float3(DirectionalPressure.x,DirectionalPressure.y,DirectionalPressure.z)/Density.x;
}

//Particles closeby slow me down or speed me up, kinda like friction.
float3 CalcViscosityForce(int PointID) {
    LavaPoint Point = Points[PointID];

    float2 Density = CachedDensities[PointID];
    if(Density.x == 0) {
        return float3(0,0,0);
    }
    float3 ViscosityForce = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    float3 MyPosition = PredictedPosition[PointID];

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(MyPosition,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                uint Index = Hashes[StartIndex].index;
                if(Index != PointID) {
                    //-----------------------------------
                    float3 Direction = PredictedPosition[Index]-MyPosition;
                    float sqrDstToNeighbour = dot(Direction,Direction);
                    float Distance = sqrt(sqrDstToNeighbour);

                    if (sqrDstToNeighbour <= sqrRadius) {
                        float3 NeighborVelocity = Points[Index].Velocity;
                        float Influence = SmoothingKernelPoly63D(Distance,SmoothingRadius);
                        ViscosityForce += (NeighborVelocity-Point.Velocity)*Influence;
                    }
                    //-----------------------------------
                }
            }
            StartIndex++;
        }
    }
    return float3(ViscosityForce.x,ViscosityForce.y,ViscosityForce.z)*ViscosityMultiplier;
}
//TODO: Add Near Pressure to prevent:
//Density Target pulls things together -> Lava Clump gets "ripped" into smaller clumps because the big one wasnt quite dense enough
//Idea: Push close particles always a little apart to disincentivise clumping on small scales?
//INFO: Increase the force multiplier makes the simulation more accurate, but requires more fps to not break down due to too big time steps

float3 CalcVelocity (int PointID) {
    LavaPoint Point = Points[PointID];
    const float3 Gravity = float3(0,-9.81,0);
    Point.Velocity+=Gravity*TimePassed;
    //F =a/m where m is the density because fluid
    Point.Velocity +=CalcPressureForce(PointID)*TimePassed;
    Point.Velocity +=CalcViscosityForce(PointID)*TimePassed;
    return Point.Velocity;
}

LavaPoint ReColor(int PointID) {
    LavaPoint Point = Points[PointID];
    Point.Color =  float4(CachedDensities[PointID].x,0,0,0);
    return Point;
}
LavaPoint HandleCollision(LavaPoint Point) {
    const float EnergyLossOnCollision = 0.5f;
    const float EnergyLossOnCollisionFloor = 0.7f;
    if (Point.Position.y < 0) {
        Point.Position.y = 0;
        Point.Velocity = float3(Point.Velocity.x,-Point.Velocity.y*EnergyLossOnCollisionFloor,Point.Velocity.z);
    }
    if (Point.Position.y > BoundsHeight) {
        Point.Position.y = BoundsHeight;
        Point.Velocity = float3(Point.Velocity.x,-Point.Velocity.y*EnergyLossOnCollisionFloor,Point.Velocity.z);
    }
    if (Point.Position.x < -BoundsWidth/2) {
        Point.Position.x = -BoundsWidth/2;
        Point.Velocity = float3(-Point.Velocity.x*EnergyLossOnCollision,Point.Velocity.y,Point.Velocity.z);
    }
    if (Point.Position.x > BoundsWidth/2) {
        Point.Position.x = BoundsWidth/2;
        Point.Velocity = float3(-Point.Velocity.x*EnergyLossOnCollision,Point.Velocity.y,Point.Velocity.z);
    }
    if (Point.Position.z < -BoundsDepth/2) {
        Point.Position.z = -BoundsDepth/2;
        Point.Velocity = float3(Point.Velocity.x,Point.Velocity.y,-Point.Velocity.z*EnergyLossOnCollision);
    }
    if (Point.Position.z > BoundsDepth/2) {
        Point.Position.z = BoundsDepth/2;
        Point.Velocity = float3(Point.Velocity.x,Point.Velocity.y,-Point.Velocity.z*EnergyLossOnCollision);
    }
    float3 Position = Point.Position;
    float3 Velocity = Point.Velocity;

    // ResolveCollisionsSDF(Position, Velocity,EnergyLossOnCollision);

    Point.Position = Position;
    Point.Velocity = Velocity;

    return Point;
}

[numthreads(10,1,1)]
void Simulation (uint3 id : SV_DispatchThreadID) {
    LavaPoint CurPoint = Points[id.x];
    CurPoint = ReColor(id.x);
    CurPoint.Velocity = CalcVelocity(id.x);
    CurPoint.Position = CalcPosition(CurPoint);
    Points[id.x] = HandleCollision(CurPoint);
}
//------------------------------------------------------------DENSITY CACHE ---------------------------------------------------------------------------------

float2 CalcDensity(int PointID) {
    float2 Density = (0,0);
    float sqrRadius = SmoothingRadius * SmoothingRadius;
    float3 MyPosition = PredictedPosition[PointID];

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(MyPosition,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                uint Index = Hashes[StartIndex].index;
                if(Index != PointID) {
                    //-----------------------------------
                    float3 Direction = PredictedPosition[Index]-MyPosition;
                    float sqrDstToNeighbour = dot(Direction, Direction);
                    float Distance = sqrt(sqrDstToNeighbour);

                    if (sqrDstToNeighbour <= sqrRadius) {
                        Density.x+=SpikyKernelPow23D(Distance,SmoothingRadius);
                        Density.y+=SpikyKernelPow33D(Distance,SmoothingRadius);
                    }
                    //-----------------------------------
                }
            }
            StartIndex++;
        }
    }
    return Density;
}
[numthreads(10,1,1)]
void DensityCache (uint3 id : SV_DispatchThreadID) {
    LavaPoint CurPoint = Points[id.x];
    CachedDensities[id.x] = CalcDensity(id.x);
}
//------------------------------------------------------------DENSITY FIELD ---------------------------------------------------------------------------------
float CalcDensity(float3 RealPos) {
    float Density = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(RealPos,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                //-----------------------------------
                float3 Direction = PredictedPosition[Hashes[StartIndex].index]-RealPos;
                float sqrDstToNeighbour = dot(Direction, Direction);
                float Distance = sqrt(sqrDstToNeighbour);

                if (sqrDstToNeighbour < sqrRadius) {
                    Density+=SpikyKernelPow23D(Distance,SmoothingRadius);
                }
                //-----------------------------------
            }
            StartIndex++;
        }
    }
    return Density;
}
bool isBorder(uint3 id) {
    if(id.x == 0) {
        return true;
    }
    if(id.x >= FieldWidth-1) {
        return true;
    }
    if(id.y == 0) {
        return true;
    }
    if(id.y >= FieldHeight-1) {
        return true;
    }
    if(id.z == 0) {
        return true;
    }
    if(id.z >= FieldDepth-1) {
        return true;
    }
    return false;
}
[numthreads(8,8,8)]
void DensityField (uint3 id : SV_DispatchThreadID) {
    if ((id.x >= FieldWidth)) return;
    if ((id.y >= FieldHeight)) return;
    if ((id.z >= FieldDepth)) return;

    float3 RealPos = float3(-FieldWidth/2,0,-FieldDepth/2)* VoxelSize + ((float3)id) * VoxelSize;

    if(isBorder(id)) {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = 0;
        DensityTexture[id] =  0;
    }else {
        DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight] = CalcDensity(RealPos);
        DensityTexture[id] = DensityValuesBuffer[id.x+id.y*FieldWidth+id.z*FieldWidth*FieldHeight];
    }
}
//------------------------------------------------------------POSITION PREDICTOR ---------------------------------------------------------------------------------
float3 PredictPosition(int PointID) {
    LavaPoint CurPoint = Points[PointID];
    float3 PredictedPosition = CurPoint.Position + (CurPoint.Velocity+float3(0,-9.81,0))/120;
    return PredictedPosition;
}
[numthreads(1024,1,1)]
void PredictPositions (uint3 id : SV_DispatchThreadID) {
    PredictedPosition[id.x] = PredictPosition(id.x);
}
//------------------------------------------------------------LOAD SDF---------------------------------------------------------------------------------
[numthreads(8,8,8)]
void LOADSDF (uint3 id : SV_DispatchThreadID) {
    if(any(id >= SDFSize)) {
        return;
    }
    SDFTexture[id] = SDFValues[id.x+id.y*SDFSize.x+id.z*SDFSize.x*SDFSize.y];
}

//------------------------------------------------------------MARCHING CUBES ---------------------------------------------------------------------------------
static const int3 vertexOffset[8] = {
    int3(0, 0, 0), // 0
    int3(1, 0, 0), // 1
    int3(0, 1, 0), // 2
    int3(1, 1, 0), // 3
    int3(0, 0, 1), // 4
    int3(1, 0, 1), // 5
    int3(0, 1, 1), // 6
    int3(1, 1, 1)  // 7
};

static const int2 edgeVertexIndices[12] = {
    int2(0, 1), // 0
    int2(1, 3), // 1
    int2(3, 2), // 2
    int2(2, 0), // 3
    int2(4, 5), // 4
    int2(5, 7), // 5
    int2(7, 6), // 6
    int2(6, 4), // 7
    int2(0, 4), // 8
    int2(1, 5), // 9
    int2(3, 7), // 10
    int2(2, 6)  // 11
};

float3 VertexInterp(float iso, float3 p1, float3 p2, float valp1, float valp2) {
    if (abs(valp2 - valp1) < 1e-6) return 0.5 * (p1 + p2);
    float t = (iso - valp1) / (valp2 - valp1);
    return lerp(p1, p2, t);
}

[numthreads(8,8,8)]
void March(uint3 id : SV_DispatchThreadID) {
    if (id.x >= GridSize.x || id.y >= GridSize.y || id.z >= GridSize.z) return;

    float cube[8];
    float3 pos[8];

    // Sample density field and convert to world positions
    for (int i = 0; i < 8; i++) {
        int3 offset = id + vertexOffset[i];
        cube[i] = DensityTexture.Load(int4(offset, 0));
        pos[i] = offset *VoxelSize;
    }

    // Build cube index
    int cubeIndex = 0;
    for (i = 0; i < 8; i++) {
        if (cube[i] < IsoLevel) cubeIndex |= (1 << i);
    }

    int edgeFlags = EdgeTable[cubeIndex];
    if (edgeFlags == 0) return;

    float3 vertList[12];

    for (i = 0; i < 12; i++) {
        if (edgeFlags & (1 << i)) {
            int2 e = edgeVertexIndices[i];
            // Use the midpoint of the edge (between the two vertices)
            vertList[i] = VertexInterp(IsoLevel, pos[e.x], pos[e.y], cube[e.x], cube[e.y]);
        }
    }

    // Create triangles
    for (i = 0; i < 16; i += 3) {
        int index1 = TriTable[cubeIndex * 16 + i];
        if (index1 == -1) break; // End of triangles for this cube

        int index2 = TriTable[cubeIndex * 16 + i + 1];
        if (index2 == -1) break; 
        int index3 = TriTable[cubeIndex * 16 + i + 2];
        if (index3 == -1) break; 

        uint baseIndex;
        InterlockedAdd(VertexCount[0], 3, baseIndex); // Reserve space for 3 vertices

        //Unity does clockwise not counterclockwise
        VertexBuffer[baseIndex+2] = vertList[index1]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex + 1] = vertList[index2]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex] = vertList[index3]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
    }
}
//------------------------------------------------------------STANDARD HASH ---------------------------------------------------------------------------------
//Idea: Turn the Simulation area into grids
//When searching for neioghbors simply look only into my and neighboring grids
//Nutzen Spacial Hash von https://cg.informatik.uni-freiburg.de/publications/2011_CGF_dataStructuresSPH.pdf
//Sp√§ter vielleich compact spacial Hash
//Compute Hash for Point
//Sort Points by Hash
//Save Starting indizes for Each Hash
//To get neibors
//Calc my hash and of each surrounding grid
//Based on the start indizes go through points and calc distance

[numthreads(10,1,1)]
void CalcHashes (uint3 id : SV_DispatchThreadID) {
    if(id.x >=ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];

    Hashes[id.x].hash =CalcHash(CurPoint.Position+float3(10,0,10));//Move Pos to always be positive
    Hashes[id.x].index = id.x;
}
//SOURCE:https://github.com/SebLague/Fluid-Sim/blob/Episode-01/Assets/Scripts/Compute%20Helpers/GPU%20Sort/Resources/BitonicMergeSort.compute
//------------------------------------------------------------------------------------------------------------------------------------------
const uint numEntries;
const uint groupWidth;
const uint groupHeight;
const uint stepIndex;

// Sort the given entries by their keys (smallest to largest)
// This is done using bitonic merge sort, and takes multiple iterations
[numthreads(128, 1, 1)]
void SortHashes (uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= numEntries) return;

    uint valueLeft = Hashes[indexLeft].hash;
    uint valueRight = Hashes[indexRight].hash;

    // Swap entries if value is descending
    if (valueLeft > valueRight) {
        HashEntry temp = Hashes[indexLeft];
        Hashes[indexLeft] = Hashes[indexRight];
        Hashes[indexRight] = temp;
    }
}
//------------------------------------------------------------------------------------------------------------------------------------------
[numthreads(1024, 1, 1)]
void CalcStartingIndizes(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    if (i >= HashesBufferSize) return;

    uint currentHash = Hashes[i].hash;

    if (i == 0) {
        // First entry always starts a new hash group
        StartingIndizes[currentHash] = 0;
    }
    else {
        uint prevHash = Hashes[i - 1].hash;

        if (currentHash != prevHash) {
            StartingIndizes[currentHash] = i;
        }
    }
}