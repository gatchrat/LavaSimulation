// MarchingCubes.compute
#pragma kernel March

RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> VertexCount;

// 3D Density Field
Texture3D<float> DensityTexture;

// Grid size and threshold
int3 GridSize;
float IsoLevel;
float VoxelSize;
float BoundsWidth;
float BoundsHeight;
float BoundsDepth;

// Lookup tables
StructuredBuffer<int> EdgeTable;      // 256 entries
StructuredBuffer<int> TriTable;       // 256 * 16 entries

static const int3 vertexOffset[8] = {
    int3(0, 0, 0), // 0
    int3(1, 0, 0), // 1
    int3(0, 1, 0), // 2
    int3(1, 1, 0), // 3
    int3(0, 0, 1), // 4
    int3(1, 0, 1), // 5
    int3(0, 1, 1), // 6
    int3(1, 1, 1)  // 7
};

static const int2 edgeVertexIndices[12] = {
    int2(0, 1), // 0
    int2(1, 3), // 1
    int2(3, 2), // 2
    int2(2, 0), // 3
    int2(4, 5), // 4
    int2(5, 7), // 5
    int2(7, 6), // 6
    int2(6, 4), // 7
    int2(0, 4), // 8
    int2(1, 5), // 9
    int2(3, 7), // 10
    int2(2, 6)  // 11
};

float3 VertexInterp(float iso, float3 p1, float3 p2, float valp1, float valp2) {
    if (abs(valp2 - valp1) < 1e-6) return 0.5 * (p1 + p2);
    float t = (iso - valp1) / (valp2 - valp1);
    return lerp(p1, p2, t);
}

[numthreads(8,8,8)]
void March(uint3 id : SV_DispatchThreadID) {
    if (id.x >= GridSize.x || id.y >= GridSize.y || id.z >= GridSize.z) return;

    float cube[8];
    float3 pos[8];

    // Sample density field and convert to world positions
    for (int i = 0; i < 8; i++) {
        int3 offset = id + vertexOffset[i];
        cube[i] = DensityTexture.Load(int4(offset, 0));
        pos[i] = offset *VoxelSize;
    }

    // Build cube index
    int cubeIndex = 0;
    for (i = 0; i < 8; i++) {
        if (cube[i] < IsoLevel) cubeIndex |= (1 << i);
    }

    int edgeFlags = EdgeTable[cubeIndex];
    if (edgeFlags == 0) return;

    float3 vertList[12];

    for (i = 0; i < 12; i++) {
        if (edgeFlags & (1 << i)) {
            int2 e = edgeVertexIndices[i];
            // Use the midpoint of the edge (between the two vertices)
            vertList[i] = VertexInterp(IsoLevel, pos[e.x], pos[e.y], cube[e.x], cube[e.y]);
        }
    }

    // Create triangles
    for (i = 0; i < 16; i += 3) {
        int index1 = TriTable[cubeIndex * 16 + i];
        if (index1 == -1) break; // End of triangles for this cube

        int index2 = TriTable[cubeIndex * 16 + i + 1];
        if (index2 == -1) break; 
        int index3 = TriTable[cubeIndex * 16 + i + 2];
        if (index3 == -1) break; 

        uint baseIndex;
        InterlockedAdd(VertexCount[0], 3, baseIndex); // Reserve space for 3 vertices

        //Unity does clockwise not counterclockwise
        VertexBuffer[baseIndex+2] = vertList[index1]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex + 1] = vertList[index2]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
        VertexBuffer[baseIndex] = vertList[index3]+float3(-BoundsWidth/2,0,-BoundsDepth/2);
    }
}