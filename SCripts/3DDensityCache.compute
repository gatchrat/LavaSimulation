// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "./Tools.compute"
RWStructuredBuffer<float> CachedDensities;
RWStructuredBuffer<float3> PredictedPosition;

float CalcDensity(int PointID) {
    float Density = 0;
    float sqrRadius = SmoothingRadius * SmoothingRadius;
    float3 MyPosition = PredictedPosition[PointID];

    for(uint i = 0; i<27;i++) {
        float3 CheckPos = OffSetPosition(MyPosition,i);
        uint CheckHash = CalcHash(CheckPos+float3(10,0,10));//Move Pos to always be positive
        uint StartIndex = StartingIndizes[CheckHash];
        if(StartIndex== 0xFFFFFFFF) {
            continue;
        }
        while(StartIndex < ParticleCount) {
            //Check if still checking in the right hashgroup
            if(Hashes[StartIndex].hash != CheckHash) {
                break;
            }
            if(Hashes[StartIndex].index >= 0 && Hashes[StartIndex].index < ParticleCount) {
                uint Index = Hashes[StartIndex].index;
                if(Index != PointID) {
                    //-----------------------------------
                    float3 Direction = PredictedPosition[Index]-MyPosition;
                    float sqrDstToNeighbour = dot(Direction, Direction);
                    float Distance = sqrt(sqrDstToNeighbour);

                    if (sqrDstToNeighbour <= sqrRadius) {
                        Density+=SpikyKernelPow23D(Distance,SmoothingRadius);
                    }
                    //-----------------------------------
                }
            }
            StartIndex++;
        }
    }
    return Density;
}

[numthreads(10,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    LavaPoint CurPoint = Points[id.x];
    CachedDensities[id.x] = CalcDensity(id.x);
}
