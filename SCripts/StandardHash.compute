
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalcHashes
#pragma kernel SortHashes
#pragma kernel CalcStartingIndizes
#include "./Tools.compute"

//Idea: Turn the Simulation area into grids
//When searching for neioghbors simply look only into my and neighboring grids
//Nutzen Spacial Hash von https://cg.informatik.uni-freiburg.de/publications/2011_CGF_dataStructuresSPH.pdf
//SpÃ¤ter vielleich compact spacial Hash
//Compute Hash for Point
//Sort Points by Hash
//Save Starting indizes for Each Hash
//To get neibors
//Calc my hash and of each surrounding grid
//Based on the start indizes go through points and calc distance

[numthreads(10,1,1)]
void CalcHashes (uint3 id : SV_DispatchThreadID) {
    if(id.x >=ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];

    Hashes[id.x].hash =CalcHash(CurPoint.Position+float3(10,0,10));//Move Pos to always be positive
    Hashes[id.x].index = id.x;
}
//SOURCE:https://github.com/SebLague/Fluid-Sim/blob/Episode-01/Assets/Scripts/Compute%20Helpers/GPU%20Sort/Resources/BitonicMergeSort.compute
//------------------------------------------------------------------------------------------------------------------------------------------
const uint numEntries;
const uint groupWidth;
const uint groupHeight;
const uint stepIndex;

// Sort the given entries by their keys (smallest to largest)
// This is done using bitonic merge sort, and takes multiple iterations
[numthreads(128, 1, 1)]
void SortHashes (uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    uint hIndex = i & (groupWidth - 1);
    uint indexLeft = hIndex + (groupHeight + 1) * (i / groupWidth);
    uint rightStepSize = stepIndex == 0 ? groupHeight - 2 * hIndex : (groupHeight + 1) / 2;
    uint indexRight = indexLeft + rightStepSize;

    // Exit if out of bounds (for non-power of 2 input sizes)
    if (indexRight >= numEntries) return;

    uint valueLeft = Hashes[indexLeft].hash;
    uint valueRight = Hashes[indexRight].hash;

    // Swap entries if value is descending
    if (valueLeft > valueRight) {
        HashEntry temp = Hashes[indexLeft];
        Hashes[indexLeft] = Hashes[indexRight];
        Hashes[indexRight] = temp;
    }
}
//------------------------------------------------------------------------------------------------------------------------------------------
[numthreads(1024, 1, 1)]
void CalcStartingIndizes(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    if (i >= HashesBufferSize) return;

    uint currentHash = Hashes[i].hash;

    if (i == 0) {
        // First entry always starts a new hash group
        StartingIndizes[currentHash] = 0;
    }
    else {
        uint prevHash = Hashes[i - 1].hash;

        if (currentHash != prevHash) {
            StartingIndizes[currentHash] = i;
        }
    }
}