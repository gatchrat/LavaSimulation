
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalcHashes
#pragma kernel SortHashes
#pragma kernel CalcStartingIndizes
#include "./Tools.compute"
#define h 3
//Idea: Turn the Simulation area into grids
//When searching for neioghbors simply look only into my and neighboring grids
//Nutzen Spacial Hash von https://cg.informatik.uni-freiburg.de/publications/2011_CGF_dataStructuresSPH.pdf
//SpÃ¤ter vielleich compact spacial Hash
//Compute Hash for Point
//Sort Points by Hash
//Save Starting indizes for Each Hash
//To get neibors
//Calc my hash and of each surrounding grid
//Based on the start indizes go through points and calc distance

[numthreads(10,1,1)]
void CalcHashes (uint3 id : SV_DispatchThreadID) {
    if(id.x >=ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];
    Hashes[id.x] = uint2(CalcHash(CurPoint.Position),id.x);
}
//TODO Sources for Bitonic Sort 
#define BLOCK_SIZE 1024
groupshared uint2 sharedHashes[BLOCK_SIZE];
[numthreads(BLOCK_SIZE, 1, 1)]
void SortHashes(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID) {
    uint tid = groupThreadID.x;

    // Load to shared memory
    sharedHashes[tid] = Hashes[tid];
    GroupMemoryBarrierWithGroupSync();

    // Bitonic sort
    for (uint k = 2; k <= BLOCK_SIZE; k <<= 1) {
        for (uint j = k >> 1; j > 0; j >>= 1) {
            uint ixj = tid ^ j;

            if (ixj > tid) {
                bool up = ((tid & k) == 0);

                uint2 a = sharedHashes[tid];
                uint2 b = sharedHashes[ixj];

                if ((a.x > b.x) == up) {
                    sharedHashes[tid] = b;
                    sharedHashes[ixj] = a;
                }
            }

            GroupMemoryBarrierWithGroupSync();
        }
    }

    // Store back to global memory
    Hashes[tid] = sharedHashes[tid];
}

[numthreads(1024, 1, 1)]
void CalcStartingIndizes(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    if (i >= NumOfPossibleHashes) return;

    uint currentHash = Hashes[i].x;

    if (i == 0) {
        // First entry always starts a new hash group
        StartingIndizes[currentHash] = 0;
    }
    else {
        uint prevHash = Hashes[i - 1].x;

        if (currentHash != prevHash) {
            StartingIndizes[currentHash] = i;
        }
    }
}