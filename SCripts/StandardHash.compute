
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalcHashes
#pragma kernel SortHashes
#pragma kernel CalcStartingIndizes
#include "./Tools.compute"

//Idea: Turn the Simulation area into grids
//When searching for neioghbors simply look only into my and neighboring grids
//Nutzen Spacial Hash von https://cg.informatik.uni-freiburg.de/publications/2011_CGF_dataStructuresSPH.pdf
//SpÃ¤ter vielleich compact spacial Hash
//Compute Hash for Point
//Sort Points by Hash
//Save Starting indizes for Each Hash
//To get neibors
//Calc my hash and of each surrounding grid
//Based on the start indizes go through points and calc distance

[numthreads(10,1,1)]
void CalcHashes (uint3 id : SV_DispatchThreadID) {
    if(id.x >=ParticleCount) {
        return;
    }
    LavaPoint CurPoint = Points[id.x];
    const uint P1 = 73856093;
    const uint P2 = 19349663;
    const uint P3 = 83492791;

    Hashes[id.x].hash =CalcHash(CurPoint.Position+float3(10,0,10));//Move Pos to always be positive
    Hashes[id.x].index = id.x;
}
//TODO Sources for Bitonic Sort 
#define BLOCK_SIZE 1024
groupshared HashEntry sharedHashes[BLOCK_SIZE];
[numthreads(BLOCK_SIZE, 1, 1)]
void SortHashes(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID) {
    uint tid = groupThreadID.x;

    // Load to shared memory
    sharedHashes[tid] = Hashes[tid];
    GroupMemoryBarrierWithGroupSync();

    // Bitonic sort
    for (uint k = 2; k <= BLOCK_SIZE; k <<= 1) {
        for (uint j = k >> 1; j > 0; j >>= 1) {
            uint ixj = tid ^ j;

            if (ixj > tid) {
                bool up = ((tid & k) == 0);

                HashEntry a = sharedHashes[tid];
                HashEntry b = sharedHashes[ixj];

                if ((a.hash > b.hash) == up) {
                    sharedHashes[tid] = b;
                    sharedHashes[ixj] = a;
                }
            }

            GroupMemoryBarrierWithGroupSync();
        }
    }

    // Store back to global memory
    Hashes[tid] = sharedHashes[tid];
}

[numthreads(1024, 1, 1)]
void CalcStartingIndizes(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;

    if (i >= HashesBufferSize) return;

    uint currentHash = Hashes[i].hash;

    if (i == 0) {
        // First entry always starts a new hash group
        StartingIndizes[currentHash] = 0;
    }
    else {
        uint prevHash = Hashes[i - 1].hash;

        if (currentHash != prevHash) {
            StartingIndizes[currentHash] = i;
        }
    }
}